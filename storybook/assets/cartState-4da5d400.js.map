{"version":3,"file":"cartState-4da5d400.js","sources":["../../src/constants/serverUrlConstants.tsx","../../src/recoil/server/serverState.ts","../../src/utils/fetchUtils.ts","../../src/recoil/cart/cartState.ts"],"sourcesContent":["export const SERVER_NAME = ['마코', '허브', '우가'] as const;\n\nexport const SERVER = {\n  [SERVER_NAME[0]]: 'https://m4co.shop',\n  [SERVER_NAME[1]]: 'https://h3rb.shop',\n  [SERVER_NAME[2]]: 'https://wuga.shop',\n} as const;\n\nexport type ServerName = (typeof SERVER_NAME)[number];\n\nexport const getProductPath = (serverName: ServerName) => {\n  return `${SERVER[serverName]}/products`;\n};\n\nexport const getCartPath = (serverName: ServerName) => {\n  return `${SERVER[serverName]}/cart-items`;\n};\n\nexport const getCouponPath = (serverName: ServerName) => {\n  return `${SERVER[serverName]}/coupons`;\n};\n","import { atom } from 'recoil';\nimport { SERVER_NAME, ServerName } from '@constants/serverUrlConstants';\n\nconst serverState = atom<ServerName>({\n  key: 'serverState',\n  default: SERVER_NAME[0],\n});\n\nexport default serverState;\n","import { CustomError } from 'types/error';\n\nexport const fetchGet = async <T>(url: string, options: RequestInit = {}): Promise<T> => {\n  try {\n    const mergedOptions = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    const response = await fetch(url, mergedOptions);\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        throw new Error('리소스를 찾을 수 없습니다');\n      }\n\n      throw new Error(`HTTP 오류! Status: ${response.status}`);\n    }\n\n    return (await response.json()) as T;\n  } catch (error) {\n    const errorMessage = (error as CustomError).message;\n    throw new Error(`Error: ${errorMessage}`);\n  }\n};\n\nexport const fetchPost = async <T>(\n  url: string,\n  body: T,\n  options: RequestInit = {}\n): Promise<Response> => {\n  try {\n    const mergedOptions = {\n      method: 'POST',\n      body: JSON.stringify(body),\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    const response = await fetch(url, mergedOptions);\n\n    if (!response.ok) {\n      throw new Error(`POST 요청이 ${response.status} 상태로 실패했습니다.`);\n    }\n\n    return response;\n  } catch (error) {\n    const errorMessage = (error as CustomError).message;\n    throw new Error(`Error: ${errorMessage}`);\n  }\n};\n\nexport const fetchPatch = async <T>(\n  url: string,\n  body: T,\n  options: RequestInit = {}\n): Promise<Response> => {\n  try {\n    const mergedOptions = {\n      method: 'PATCH',\n      body: JSON.stringify(body),\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    const response = await fetch(url, mergedOptions);\n\n    if (!response.ok) {\n      throw new Error(`PATCH 요청이 ${response.status} 상태로 실패했습니다.`);\n    }\n\n    return response;\n  } catch (error) {\n    const errorMessage = (error as CustomError).message;\n    throw new Error(`Error: ${errorMessage}`);\n  }\n};\n\nexport const fetchDelete = async (url: string, options: RequestInit = {}): Promise<Response> => {\n  try {\n    const mergedOptions = {\n      method: 'DELETE',\n      ...options,\n    };\n\n    const response = await fetch(url, mergedOptions);\n\n    if (!response.ok) {\n      throw new Error(`DELETE 요청이 ${response.status} 상태로 실패했습니다.`);\n    }\n\n    return response;\n  } catch (error) {\n    const errorMessage = (error as CustomError).message;\n    throw new Error(`Error: ${errorMessage}`);\n  }\n};\n","import { useCallback, useMemo } from 'react';\nimport {\n  atom,\n  selector,\n  useRecoilRefresher_UNSTABLE,\n  useRecoilState,\n  useRecoilValue,\n} from 'recoil';\nimport serverState from '@recoil/server/serverState';\nimport { fetchGet } from '@utils/fetchUtils';\nimport { getCartPath } from '@constants/serverUrlConstants';\nimport { CartItemType } from '@type/cartType';\n\nexport const CartItemQuery = selector({\n  key: 'cartListWithInfoState/default',\n  get: async ({ get }) => {\n    const server = get(serverState);\n    const cartProducts: CartItemType[] | null = await fetchGet(getCartPath(server));\n\n    if (!cartProducts) {\n      throw new Error('리코일에서 장바구니 목록을 불러올 수 없습니다.');\n    }\n\n    return cartProducts.map((cartProduct) => {\n      cartProduct.isSelect = true;\n      return cartProduct;\n    });\n  },\n});\n\nconst cartState = atom<CartItemType[]>({\n  key: 'cartListWithInfoState',\n  default: [],\n});\n\nexport default cartState;\n\nexport const useRefreshCartList = () => useRecoilRefresher_UNSTABLE(cartState);\n\nexport const useCartList = () => useRecoilValue(cartState);\n\nexport const useCheckCart = () => {\n  const [cart, setCart] = useRecoilState(cartState);\n\n  const toggleMap = useMemo<{ [id: number]: boolean }>(() => {\n    return cart.reduce((acc, { product, isSelect }) => {\n      const { id } = product;\n      Object.assign(acc, { [id]: isSelect });\n      return acc;\n    }, {});\n  }, [cart]);\n\n  const isAllChecked = cart.every((cartItem) => cartItem.isSelect);\n\n  const checkedCount = Object.values(toggleMap).reduce((acc, cur) => {\n    if (cur) {\n      return acc + 1;\n    } else {\n      return acc;\n    }\n  }, 0);\n\n  const isCheckedById = useCallback((id: number) => toggleMap[id], [toggleMap]);\n\n  const toggleAllCartItem = useCallback(() => {\n    setCart((prevCart) => {\n      return prevCart.map((item) => ({ ...item, checked: !isAllChecked }));\n    });\n  }, [isAllChecked, setCart]);\n\n  const deleteCheckedItems = () => {\n    setCart(cart.filter((item) => item.isSelect === false));\n\n    // 이 부분 확인 필요\n  };\n\n  return {\n    isAllChecked,\n    checkedCount,\n    isCheckedById,\n    toggleAllCartItem,\n    deleteCheckedItems,\n  };\n};\n"],"names":["SERVER_NAME","SERVER","getProductPath","serverName","getCartPath","getCouponPath","serverState","atom","fetchGet","url","options","mergedOptions","response","error","errorMessage","selector","get","server","cartProducts","cartProduct","cartState","useRefreshCartList","useRecoilRefresher_UNSTABLE"],"mappings":"kFAAO,MAAAA,EAAA,CAAA,KAAA,KAAA,IAAA,EAEAC,EAAA,CAAe,CAAAD,EAAA,CAAA,CAAA,EAAA,oBACF,CAAAA,EAAA,CAAA,CAAA,EAAA,oBACA,CAAAA,EAAA,CAAA,CAAA,EAAA,mBAEpB,EAIOE,EAAAC,GACL,GAAAF,EAAAE,CAAA,aAGKC,EAAAD,GACL,GAAAF,EAAAE,CAAA,eAGKE,EAAAF,GACL,GAAAF,EAAAE,CAAA,oVChBF,MAAMG,EAAcC,EAAiB,CACnC,IAAK,cACL,QAASP,EAAY,CAAC,CACxB,CAAC,ECJYQ,EAAW,MAAUC,EAAaC,EAAuB,KAAmB,CACnF,GAAA,CACF,MAAMC,EAAgB,CACpB,OAAQ,MACR,QAAS,CACP,eAAgB,mBAChB,GAAGD,EAAQ,OACb,EACA,GAAGA,CAAA,EAGCE,EAAW,MAAM,MAAMH,EAAKE,CAAa,EAE3C,GAAA,CAACC,EAAS,GACR,MAAAA,EAAS,SAAW,IAChB,IAAI,MAAM,gBAAgB,EAG5B,IAAI,MAAM,oBAAoBA,EAAS,QAAQ,EAG/C,OAAA,MAAMA,EAAS,aAChBC,GACP,MAAMC,EAAgBD,EAAsB,QACtC,MAAA,IAAI,MAAM,UAAUC,GAAc,CAC1C,CACF,ECf6BC,EAAS,CACpC,IAAK,gCACL,IAAK,MAAO,CAAE,IAAAC,KAAU,CAChB,MAAAC,EAASD,EAAIV,CAAW,EACxBY,EAAsC,MAAMV,EAASJ,EAAYa,CAAM,CAAC,EAE9E,GAAI,CAACC,EACG,MAAA,IAAI,MAAM,4BAA4B,EAGvC,OAAAA,EAAa,IAAKC,IACvBA,EAAY,SAAW,GAChBA,EACR,CACH,CACF,CAAC,EAED,MAAMC,EAAYb,EAAqB,CACrC,IAAK,wBACL,QAAS,CAAC,CACZ,CAAC,EAIYc,EAAqB,IAAMC,EAA4BF,CAAS"}